// Copyright 2019 Conflux Foundation. All rights reserved.
// Conflux is free software and distributed under GNU General Public License.
// See http://www.gnu.org/licenses/

use std::fmt::Display;

use crate::{
    observer::{ErrorUnwind, Observer},
    state::Substate,
};
use cfx_bytes::Bytes;
use cfx_types::{Address, AddressWithSpace, U256};
use primitives::{
    receipt::{SortedStorageChanges, StorageChange},
    LogEntry, TransactionWithSignature,
};
use solidity_abi::{ABIDecodable, ABIDecodeError};

use super::{
    fresh_executive::CostInfo,
    pre_checked_executive::{ExecutiveReturn, RefundInfo},
};

#[derive(Debug, PartialEq, Clone)]
pub struct Executed {
    /// Gas used during execution of transaction.
    pub gas_used: U256,

    /// Fee that need to be paid by execution of this transaction.
    pub fee: U256,

    /// Gas charged during execution of transaction.
    pub gas_charged: U256,

    /// If the gas fee is born by designated sponsor.
    pub gas_sponsor_paid: bool,

    /// Vector of logs generated by transaction.
    pub logs: Vec<LogEntry>,

    /// If the storage cost is born by designated sponsor.
    pub storage_sponsor_paid: bool,

    /// Any accounts that occupy some storage.
    pub storage_collateralized: Vec<StorageChange>,

    /// Any accounts that release some storage.
    pub storage_released: Vec<StorageChange>,

    /// Addresses of contracts created during execution of transaction.
    /// Ordered from earliest creation.
    ///
    /// eg. sender creates contract A and A in constructor creates contract B
    ///
    /// B creation ends first, and it will be the first element of the vector.
    pub contracts_created: Vec<AddressWithSpace>,
    /// Transaction output.
    pub output: Bytes,
    /// The trace of this transaction.
    pub trace: Vec<ExecTrace>,
    /// Only for the virtual call, an accurate gas estimation for gas usage,
    pub estimated_gas_limit: Option<U256>,
    /// Only for the virtual call, the minimum storage limit should returned in
    /// estimate gas and collateral.
    pub estimated_storage_limit: u64,
}

impl Executed {
    pub fn not_enough_balance_fee_charged(
        tx: &TransactionWithSignature, fee: &U256, mut gas_sponsor_paid: bool,
        mut storage_sponsor_paid: bool, trace: Vec<ExecTrace>, spec: &Spec,
    ) -> Self
    {
        let gas_charged = if *tx.gas_price() == U256::zero() {
            U256::zero()
        } else {
            fee / tx.gas_price()
        };
        if !spec.cip78b {
            gas_sponsor_paid = false;
            storage_sponsor_paid = false;
        }
        Self {
            gas_used: *tx.gas(),
            gas_charged,
            fee: fee.clone(),
            gas_sponsor_paid,
            logs: vec![],
            contracts_created: vec![],
            storage_sponsor_paid,
            storage_collateralized: Vec::new(),
            storage_released: Vec::new(),
            output: Default::default(),
            trace,
            estimated_gas_limit: None,
            estimated_storage_limit: 0,
        }
    }

    pub(super) fn execution_error_fully_charged(
        tx: &TransactionWithSignature, cost: CostInfo, observer: Observer,
        spec: &Spec,
    ) -> Self
    {
        let mut storage_sponsor_paid = cost.storage_sponsored;
        let mut gas_sponsor_paid = cost.gas_sponsored;

        let trace = observer.tracer.map_or(Default::default(), |t| t.drain());

        if !spec.cip78b {
            gas_sponsor_paid = false;
            storage_sponsor_paid = false;
        }
        Self {
            gas_used: *tx.gas(),
            gas_charged: *tx.gas(),
            fee: tx.gas().saturating_mul(*tx.gas_price()),
            gas_sponsor_paid,
            logs: vec![],
            contracts_created: vec![],
            storage_sponsor_paid,
            storage_collateralized: Vec::new(),
            storage_released: Vec::new(),
            output: Default::default(),
            trace,
            estimated_gas_limit: None,
            estimated_storage_limit: 0,
        }
    }

    pub(super) fn from_executive_return(
        r: &ExecutiveReturn, refund_info: RefundInfo, cost: CostInfo,
        substate: Substate, observer: Observer, base_gas_required: u64,
        spec: &Spec,
    ) -> Self
    {
        let output = r.return_data.to_vec();

        let SortedStorageChanges {
            storage_collateralized,
            storage_released,
        } = if r.apply_state {
            substate.compute_storage_changes()
        } else {
            Default::default()
        };

        let RefundInfo {
            gas_used,
            gas_charged,
            fees_value: fee,
            ..
        } = refund_info;
        let storage_sponsor_paid = if spec.cip78a {
            cost.storage_sponsored
        } else {
            cost.storage_sponsor_eligible
        };

        let gas_sponsor_paid = cost.gas_sponsored;

        let trace = observer.tracer.map_or(Default::default(), |t| t.drain());

        let estimated_gas_limit = observer
            .gas_man
            .as_ref()
            .map(|g| g.gas_required() * 7 / 6 + base_gas_required);

        let estimated_storage_limit =
            if let Some(x) = storage_collateralized.first() {
                x.collaterals.as_u64()
            } else {
                0
            };

        Executed {
            gas_used,
            gas_charged,
            fee,
            gas_sponsor_paid,
            logs: substate.logs.to_vec(),
            contracts_created: substate.contracts_created.to_vec(),
            storage_sponsor_paid,
            storage_collateralized,
            storage_released,
            output,
            trace,
            estimated_gas_limit,
            estimated_storage_limit,
        }
    }

    pub fn decode_error<F, Addr: Display>(
        &self, format_address: F,
    ) -> (String, String, Vec<String>)
    where F: Fn(&Address) -> Addr {
        // When a revert exception happens, there is usually an error in
        // the sub-calls. So we return the trace
        // information for debugging contract.
        let errors = ErrorUnwind::from_traces(&self.trace)
            .errors
            .iter()
            .map(|(addr, error)| format!("{}: {}", format_address(addr), error))
            .collect::<Vec<String>>();

        // Decode revert error
        let revert_error = revert_reason_decode(&self.output);
        let revert_error = if !revert_error.is_empty() {
            format!(": {}.", revert_error)
        } else {
            format!(".")
        };

        // Try to fetch the innermost error.
        let innermost_error = if errors.len() > 0 {
            format!(" Innermost error is at {}.", errors[0])
        } else {
            String::default()
        };
        (revert_error, innermost_error, errors)
    }
}

pub fn revert_reason_decode(output: &Bytes) -> String {
    const MAX_LENGTH: usize = 50;
    let decode_result = if output.len() < 4 {
        Err(ABIDecodeError("Uncompleted Signature"))
    } else {
        let (sig, data) = output.split_at(4);
        if sig != [8, 195, 121, 160] {
            Err(ABIDecodeError("Unrecognized Signature"))
        } else {
            String::abi_decode(data)
        }
    };
    match decode_result {
        Ok(str) => {
            if str.len() < MAX_LENGTH {
                str
            } else {
                format!("{}...", str[..MAX_LENGTH].to_string())
            }
        }
        Err(_) => "".to_string(),
    }
}

use crate::observer::trace::ExecTrace;
use cfx_vm_types::Spec;

#[cfg(test)]
use rustc_hex::FromHex;

#[test]
fn test_decode_result() {
    let input_hex =
        "08c379a0\
         0000000000000000000000000000000000000000000000000000000000000020\
         0000000000000000000000000000000000000000000000000000000000000018\
         e699bae59586e4b88de8b6b3efbc8ce8afb7e58585e580bc0000000000000000";
    assert_eq!(
        "智商不足，请充值".to_string(),
        revert_reason_decode(&input_hex.from_hex().unwrap())
    );
}
